<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Solar System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* The webcam feed (mirrored for natural interaction) */
        #input_video { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 240px; 
            height: 180px; 
            z-index: 2; 
            border: 2px solid rgba(255,255,255,0.3); 
            border-radius: 10px;
            transform: scaleX(-1); /* Mirror the video */
            opacity: 0.7;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; pointer-events: none; z-index: 10;
        }

        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 5;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #ffcc00; }
        p { margin: 5px 0; font-size: 0.9rem; }
        .key { font-weight: bold; color: #00ffff; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing Neural Networks...</div>
    
    <div id="ui-layer">
        <h1>Solar Hand Control</h1>
        <p><span class="key">1 Hand (Open):</span> Move to Rotate View</p>
        <p><span class="key">1 Hand (Fist):</span> Change Particle Color</p>
        <p><span class="key">2 Hands:</span> Spread to Zoom In/Out</p>
        <p><i>Status: <span id="status">Waiting for camera...</span></i></p>
    </div>

    <video id="input_video" autoplay playsinline></video>
    
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // 1. THREE.JS SETUP (The Solar System)
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0005);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.z = 500;
    camera.position.y = 100;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // --- Create Particles ---
    // Helper to create a glowing texture
    function createTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 32, 32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const particleCount = 2000;
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    const sizes = [];
    const orbitData = []; // Store angle and speed for animation

    const color1 = new THREE.Color(0xffaa33); // Inner
    const color2 = new THREE.Color(0x3366ff); // Outer

    for (let i = 0; i < particleCount; i++) {
        // Spiral galaxy distribution
        const angle = Math.random() * Math.PI * 2;
        const radius = 50 + Math.random() * 400; // Distance from sun
        const drift = (Math.random() - 0.5) * 40; // Height variation

        const x = Math.cos(angle) * radius;
        const y = drift;
        const z = Math.sin(angle) * radius;

        positions.push(x, y, z);

        // Store orbit data
        orbitData.push({
            radius: radius,
            angle: angle,
            speed: (10 / radius) * (Math.random() * 0.5 + 0.5), // Closer moves faster
            yOffset: drift
        });

        // Color mix based on radius
        const mixedColor = color1.clone().lerp(color2, radius / 400);
        colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
        sizes.push(4 + Math.random() * 5);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    const material = new THREE.PointsMaterial({
        size: 5,
        vertexColors: true,
        map: createTexture(),
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true
    });

    const system = new THREE.Points(geometry, material);
    scene.add(system);

    // Add a central Sun
    const sunGeo = new THREE.SphereGeometry(20, 32, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sun);
    
    // Sun Glow
    const sunGlowGeo = new THREE.SpriteMaterial({ 
        map: createTexture(), 
        color: 0xff4400, 
        transparent: true, 
        blending: THREE.AdditiveBlending 
    });
    const sunGlow = new THREE.Sprite(sunGlowGeo);
    sunGlow.scale.set(100, 100, 1.0);
    scene.add(sunGlow);


    // ==========================================
    // 2. STATE MANAGEMENT & LOGIC
    // ==========================================
    const state = {
        targetRotationX: 0,
        targetRotationY: 0,
        currentRotationX: 0,
        currentRotationY: 0,
        zoom: 500,
        targetZoom: 500,
        colorHue: 0,
        isFist: false,
        lastFistTime: 0
    };

    function changeColors() {
        const now = Date.now();
        // Debounce color change (prevent rapid flickering)
        if (now - state.lastFistTime > 500) {
            state.lastFistTime = now;
            
            // Generate random colors
            const c1 = new THREE.Color().setHSL(Math.random(), 1, 0.5);
            const c2 = new THREE.Color().setHSL(Math.random(), 1, 0.5);
            
            const cols = geometry.attributes.color.array;
            
            for (let i = 0; i < particleCount; i++) {
                const radius = orbitData[i].radius;
                // Lerp new colors
                const mixed = c1.clone().lerp(c2, radius / 400);
                cols[i * 3] = mixed.r;
                cols[i * 3 + 1] = mixed.g;
                cols[i * 3 + 2] = mixed.b;
            }
            geometry.attributes.color.needsUpdate = true;
            
            sunMat.color.setHSL(Math.random(), 1, 0.5);
            sunGlow.material.color.setHSL(Math.random(), 1, 0.5);
        }
    }

    // ==========================================
    // 3. MEDIAPIPE HAND TRACKING
    // ==========================================
    const videoElement = document.getElementById('input_video');
    const statusText = document.getElementById('status');
    const loadingDiv = document.getElementById('loading');

    function onResults(results) {
        loadingDiv.style.display = 'none';
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            statusText.innerText = `Hands Detected: ${results.multiHandLandmarks.length}`;
            statusText.style.color = '#00ff00';

            const hand1 = results.multiHandLandmarks[0];
            const hand2 = results.multiHandLandmarks.length > 1 ? results.multiHandLandmarks[1] : null;

            // --- Logic for 2 Hands: ZOOM ---
            if (hand2) {
                // Calculate distance between the wrists (landmark 0) or index fingers (landmark 8)
                const dx = hand1[0].x - hand2[0].x;
                const dy = hand1[0].y - hand2[0].y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // Map distance to zoom (Inverted: hands apart = closer zoom)
                // Distance usually 0.2 to 0.8
                const zoomFactor = 1000 - (distance * 1000); 
                state.targetZoom = Math.max(100, Math.min(1200, zoomFactor));
            } 
            
            // --- Logic for 1 Hand: ROTATE & COLOR ---
            else {
                // 1. ROTATION (Based on Palm Position - Landmark 9)
                const x = hand1[9].x; // 0.0 to 1.0
                const y = hand1[9].y; // 0.0 to 1.0
                
                // Map 0-1 to rotation angles
                // Center (0.5) is 0 rotation.
                state.targetRotationY = (x - 0.5) * 4; // Horizontal movement rotates Y
                state.targetRotationX = (y - 0.5) * 2; // Vertical movement rotates X

                // 2. GESTURE DETECTION (Fist)
                // Check if fingertips (8, 12, 16, 20) are below finger PIP joints (6, 10, 14, 18)
                // Note: Y coordinates increase downwards
                const isFist = (
                    hand1[8].y > hand1[6].y && 
                    hand1[12].y > hand1[10].y && 
                    hand1[16].y > hand1[14].y && 
                    hand1[20].y > hand1[18].y
                );

                if (isFist) {
                    changeColors();
                }
            }
        } else {
            statusText.innerText = "No hands detected";
            statusText.style.color = '#ffff00';
            // Slowly return to default rotation if no hands
            state.targetRotationX = state.targetRotationX * 0.95;
            state.targetRotationY = state.targetRotationY * 0.95;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();


    // ==========================================
    // 4. ANIMATION LOOP
    // ==========================================
    
    function animate() {
        requestAnimationFrame(animate);

        // --- Smooth Camera Movement (LERP) ---
        state.currentRotationX += (state.targetRotationX - state.currentRotationX) * 0.05;
        state.currentRotationY += (state.targetRotationY - state.currentRotationY) * 0.05;
        state.zoom += (state.targetZoom - state.zoom) * 0.05;

        // Convert spherical coords to cartesian
        const r = state.zoom;
        const theta = state.currentRotationY; 
        const phi = state.currentRotationX;

        camera.position.x = r * Math.sin(theta);
        camera.position.z = r * Math.cos(theta);
        camera.position.y = r * Math.sin(phi);
        
        camera.lookAt(scene.position);

        // --- Particle Animation (Orbit) ---
        const positions = geometry.attributes.position.array;
        
        for (let i = 0; i < particleCount; i++) {
            const d = orbitData[i];
            
            // Update angle
            d.angle += d.speed * 0.001;

            // Recalculate X/Z
            positions[i * 3] = Math.cos(d.angle) * d.radius;
            positions[i * 3 + 2] = Math.sin(d.angle) * d.radius;
            // Y stays mostly the same with slight wobble
            positions[i * 3 + 1] = d.yOffset + Math.sin(Date.now() * 0.001 + i) * 2;
        }
        geometry.attributes.position.needsUpdate = true;

        // Rotate sun slightly
        sun.rotation.y += 0.005;

        renderer.render(scene, camera);
    }

    animate();

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>