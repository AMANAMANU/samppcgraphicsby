<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System - Earth Focus</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #input_video { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 240px; height: 180px; z-index: 2; 
            border: 2px solid rgba(255,255,255,0.3); 
            border-radius: 10px;
            transform: scaleX(-1); opacity: 0.7;
        }

        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 5;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.6);
            padding: 15px; border-radius: 8px; pointer-events: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #ffcc00; }
        p { margin: 5px 0; font-size: 0.9rem; }
        .key { font-weight: bold; color: #00ffff; }
        .alert { color: #ff4444; font-weight: bold; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>Solar Gesture Control</h1>
        <p><span class="key">‚òùÔ∏è Index Finger:</span> Toggle Earth/Sun View</p>
        <p><span class="key">‚úä Fist:</span> Change Colors</p>
        <p><span class="key">‚úã Open Hand:</span> Rotate Camera</p>
        <p><span class="key">üëê Two Hands:</span> Zoom</p>
        <p><i>Current Focus: <span id="focus-status" style="color:yellow">SUN</span></i></p>
    </div>

    <video id="input_video" autoplay playsinline></video>
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // 1. THREE.JS SETUP
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0005);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.z = 500;
    camera.position.y = 100;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // --- SUN ---
    const sunGeo = new THREE.SphereGeometry(25, 32, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    scene.add(sun);
    
    // Sun Glow Sprite
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
    const glowTex = new THREE.Texture(canvas); glowTex.needsUpdate = true;
    
    const sunGlow = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowTex, color: 0xff4400, blending: THREE.AdditiveBlending }));
    sunGlow.scale.set(120, 120, 1);
    scene.add(sunGlow);

    // --- EARTH ---
    const earthGroup = new THREE.Group(); // Pivot point for orbit
    scene.add(earthGroup);

    const earthGeo = new THREE.SphereGeometry(10, 32, 32);
    const earthMat = new THREE.MeshPhongMaterial({ color: 0x2233ff, emissive: 0x112244 });
    const earth = new THREE.Mesh(earthGeo, earthMat);
    earth.position.set(150, 0, 0); // Distance from Sun
    earthGroup.add(earth);

    // Earth Trail/Orbit Line
    const orbitCurve = new THREE.EllipseCurve(0, 0, 150, 150, 0, 2 * Math.PI, false, 0);
    const orbitPoints = orbitCurve.getPoints(100);
    const orbitGeo = new THREE.BufferGeometry().setFromPoints(orbitPoints);
    const orbitMat = new THREE.LineBasicMaterial({ color: 0x4444ff, opacity: 0.3, transparent: true });
    const orbitLine = new THREE.Line(orbitGeo, orbitMat);
    orbitLine.rotation.x = Math.PI / 2;
    scene.add(orbitLine);

    // Lighting for Earth
    const light = new THREE.PointLight(0xffffff, 1.5, 500);
    scene.add(light); // Sun light

    // --- PARTICLES ---
    const particlesGeo = new THREE.BufferGeometry();
    const count = 1500;
    const posArray = new Float32Array(count * 3);
    const colArray = new Float32Array(count * 3);
    const orbitData = [];

    const c1 = new THREE.Color(0xffaa33);
    const c2 = new THREE.Color(0x3366ff);

    for(let i=0; i<count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = 60 + Math.random() * 400;
        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;
        const y = (Math.random() - 0.5) * 30;
        
        posArray[i*3] = x; posArray[i*3+1] = y; posArray[i*3+2] = z;
        
        orbitData.push({ r: r, angle: angle, speed: (10/r) * 0.5, y: y });

        const mixed = c1.clone().lerp(c2, r/400);
        colArray[i*3] = mixed.r; colArray[i*3+1] = mixed.g; colArray[i*3+2] = mixed.b;
    }
    particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    particlesGeo.setAttribute('color', new THREE.BufferAttribute(colArray, 3));

    const particles = new THREE.Points(particlesGeo, new THREE.PointsMaterial({
        size: 3, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true
    }));
    scene.add(particles);

    // ==========================================
    // 2. LOGIC & STATE
    // ==========================================
    const state = {
        targetRotX: 0, targetRotY: 0,
        currRotX: 0, currRotY: 0,
        zoom: 400, targetZoom: 400,
        
        focusTarget: 'sun', // 'sun' or 'earth'
        lastToggleTime: 0,
        
        cameraLookAt: new THREE.Vector3(0,0,0), // Interpolated lookAt
        earthAngle: 0
    };

    const focusText = document.getElementById('focus-status');

    function toggleFocus() {
        const now = Date.now();
        if (now - state.lastToggleTime > 1000) { // 1 second cooldown
            state.lastToggleTime = now;
            state.focusTarget = (state.focusTarget === 'sun') ? 'earth' : 'sun';
            
            focusText.innerText = state.focusTarget.toUpperCase();
            focusText.style.color = state.focusTarget === 'sun' ? 'yellow' : 'cyan';
            
            // Adjust zoom for better view automatically
            state.targetZoom = state.focusTarget === 'earth' ? 80 : 400; 
        }
    }

    function randomizeColors() {
        if(Date.now() - state.lastToggleTime < 500) return; // Share debounce
        const r1 = Math.random(), r2 = Math.random();
        const colors = particles.geometry.attributes.color.array;
        const _c1 = new THREE.Color().setHSL(r1, 1, 0.5);
        const _c2 = new THREE.Color().setHSL(r2, 1, 0.5);
        
        for(let i=0; i<count; i++) {
            const mixed = _c1.clone().lerp(_c2, orbitData[i].r/400);
            colors[i*3] = mixed.r; colors[i*3+1] = mixed.g; colors[i*3+2] = mixed.b;
        }
        particles.geometry.attributes.color.needsUpdate = true;
    }

    // ==========================================
    // 3. HAND TRACKING
    // ==========================================
    const videoElement = document.getElementById('input_video');

    function onResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

        const h1 = results.multiHandLandmarks[0];
        const h2 = results.multiHandLandmarks.length > 1 ? results.multiHandLandmarks[1] : null;

        // --- 2 Hands: ZOOM ---
        if (h2) {
            const d = Math.hypot(h1[0].x - h2[0].x, h1[0].y - h2[0].y);
            // Inverted: hands apart (d=0.8) -> zoom=100, hands close (d=0.1) -> zoom=800
            const z = 800 - (d * 800);
            state.targetZoom = Math.max(50, Math.min(1000, z));
        } 
        else {
            // --- 1 Hand Logic ---
            
            // Check Fingers (Tip y < PIP y means finger is extended UP in screen space)
            // Note: y=0 is top, y=1 is bottom. So Small Y is UP.
            const indexUp = h1[8].y < h1[6].y;
            const middleClosed = h1[12].y > h1[10].y;
            const ringClosed = h1[16].y > h1[14].y;
            const pinkyClosed = h1[20].y > h1[18].y;

            // GESTURE: Pointing Up (Index only)
            if (indexUp && middleClosed && ringClosed && pinkyClosed) {
                toggleFocus();
            }
            // GESTURE: Fist (All closed)
            else if (!indexUp && middleClosed && ringClosed && pinkyClosed) {
                randomizeColors();
            }
            // GESTURE: Open Hand (Rotate)
            else {
                // Center is 0.5
                state.targetRotY = (h1[9].x - 0.5) * 5; 
                state.targetRotX = (h1[9].y - 0.5) * 3;
            }
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // ==========================================
    // 4. ANIMATION
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);

        // 1. Move Earth
        state.earthAngle += 0.005; // Orbit speed
        earth.position.x = Math.cos(state.earthAngle) * 150;
        earth.position.z = Math.sin(state.earthAngle) * 150;
        earth.rotation.y += 0.02; // Earth spin

        // 2. Camera Controls Smoothing
        state.currRotX += (state.targetRotX - state.currRotX) * 0.05;
        state.currRotY += (state.targetRotY - state.currRotY) * 0.05;
        state.zoom += (state.targetZoom - state.zoom) * 0.05;

        // 3. Determine Focus Point (Lerp for smooth transition)
        const targetVec = (state.focusTarget === 'earth') ? earth.position : new THREE.Vector3(0,0,0);
        state.cameraLookAt.lerp(targetVec, 0.05);

        // 4. Calculate Camera Position
        // We orbit around the *current focus point*
        const r = state.zoom;
        const theta = state.currRotY;
        const phi = state.currRotX;

        // Basic orbital math relative to the lookAt target
        camera.position.x = state.cameraLookAt.x + r * Math.sin(theta);
        camera.position.y = state.cameraLookAt.y + r * Math.sin(phi);
        camera.position.z = state.cameraLookAt.z + r * Math.cos(theta);

        camera.lookAt(state.cameraLookAt);

        // 5. Particles
        const positions = particles.geometry.attributes.position.array;
        for(let i=0; i<count; i++){
            const d = orbitData[i];
            d.angle += d.speed * 0.01;
            positions[i*3] = Math.cos(d.angle) * d.r;
            positions[i*3+2] = Math.sin(d.angle) * d.r;
        }
        particles.geometry.attributes.position.needsUpdate = true;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>